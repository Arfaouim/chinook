# -*- coding: utf-8 -*-
"""
Created on Fri Aug 31 16:02:49 2018

@author: rday

Calculation of Density of States

"""
import numpy as np
import matplotlib.pyplot as plt
import ubc_tbarpes.klib as klib

def region(num):
    '''
    Generate a symmetric grid of points in number of lattice vectors. The tacit assumption is a 3 dimensional lattice
    args: num -- integer--grid will have size 2*num+1 in each direction
    returns numpy array of size ((2*num+1)**3,3) with centre value of first entry of (-num,-num,-num),...,(0,0,0),...,(num,num,num)
    '''
    num_symm = 2*num+1
    return np.array([[int(i/num_symm**2)-num,int(i/num_symm)%num_symm-num,i%num_symm-num] for i in range((num_symm)**3)])


def _b_lattice_(avec):
    '''
    Generate the set of nearest and next-nearest reciprocal lattice vectors
    args:
        avec: numpy array of 3x3 float lattice vectors (row based)
    return:
        blatt: numpy array of 27x3 float
    '''
    bvec= klib.bvectors(avec)
    blatt = np.dot(region(1),bvec)
    return blatt

def raw_mesh(blatt,N):
    '''
    Define a mesh of points filling the region of k-space bounded by the set of reciprocal lattice points generated by _b_lattice_
    These will be further reduced by BZ_gen(mesh) to find points which are within the first-Brillouin zone
    args:
        blatt: numpy array of 27x3 float
        N: integer, coarse estimation of number of k-points:
    return:
        mesh: numpy array of mesh points, set by the N 
    '''
    limits = np.array([[blatt[:,ii].min(),blatt[:,ii].max()] for ii in range(3)])
    print(limits[:,1]-limits[:,0])
    if type(N)==int:
        L_max = (limits[:,1]-limits[:,0]).min()
        dk = [(L_max/N)]*3
    elif type(N)==tuple or type(N)==list or type(N)==np.ndarray:
        if len(N)==3:
            dk = [(limits[i,1]-limits[i,0])/N[i] for i in range(3)]
        else:
            print('ERROR: Must pass 3 numbers if passing a list/tuple/array')
            return []
        
    else:
        print('Invalid K division type. Pass only integer or list/tuple/array of 3 integer values')
        return []
    x,y,z = np.arange(limits[0,0],limits[0,1]+dk[0],dk[0]),np.arange(limits[1,0],limits[1,1]+dk[1],dk[1]),np.arange(limits[2,0],limits[2,1]+dk[2],dk[2])
    X,Y,Z = np.meshgrid(x,y,z)
    Kpts = np.array([[X[i,j,k],Y[i,j,k],Z[i,j,k]] for k in range(len(z)) for j in range(len(y)) for i in range(len(x))])
    return Kpts

def BZ_gen(blatt,mesh):
    '''
    Determine and select only k-points corresponding to the first Brillouin zone, by simply classifying points on the basis
    of whether or not the closest lattice point is the origin. By construction, the origin is index 13 of the blatt. If for some reason
    it is not, return error
    '''
    if np.linalg.norm(blatt[13])>0:
        print('FORMAT ERROR: invalid Reciprocal Lattice Point array passed. Please use _b_lattice_() to generate these points')
        return []
    else:
        dv = np.array([np.linalg.norm(m-blatt,axis=1) for m in mesh])

        bz_pts = np.array([mesh[i] for i in range(len(dv)) if (13 in np.where(dv[i]==dv[i].min())[0]) ])
        return bz_pts
    

def plt_pts(pts):
    '''
    Plot an array of points
    args:
        pts: numpy array shape N x 3
    return:
        NA
    '''
    fig = plt.figure()
    ax = fig.add_subplot(111,projection='3d')
    ax.scatter(pts[:,0],pts[:,1],pts[:,2])
    



if __name__ == "__main__":
    avec = np.array([[5,0,0],[0,5,0],[0,0,10]])
    blatt = _b_lattice_(avec)
    mesh = raw_mesh(blatt,(10,10,3))
    bz = BZ_gen(blatt,mesh)
    
    plt_pts(blatt)  
    plt_pts(mesh)
    plt_pts(bz)
    
    

    

