
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Tight Binding &#8212; chinook 1.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Model Diagnostics" href="operator.html" />
    <link rel="prev" title="ARPES Simulation" href="arpes.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="toctree-wrapper compound">
</div>
<div class="section" id="tight-binding">
<h1>Tight Binding<a class="headerlink" href="#tight-binding" title="Permalink to this headline">¶</a></h1>
<p>The user tight-binding model contains all relevant information regarding the orbital basis, the model Hamiltonian (in addition to eigenvalues/eigenvectors), as well as the momentum domain of interest. In addition, the tight-binding class contains all relevant methods required to extract this information.</p>
<div class="section" id="module-chinook.build_lib">
<span id="build-lib"></span><h2>build_lib:<a class="headerlink" href="#module-chinook.build_lib" title="Permalink to this headline">¶</a></h2>
<p>Created on Sat Nov 18 11:15:35 2017</p>
<p>&#64;author: ryanday</p>
<p>MIT License</p>
<p>Copyright (c) 2018 Ryan Patrick Day</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the “Software”), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>
<dl class="function">
<dt id="chinook.build_lib.gen_K">
<code class="descclassname">chinook.build_lib.</code><code class="descname">gen_K</code><span class="sig-paren">(</span><em>Kdic</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.build_lib.gen_K" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate k-path for TB model to be diagonalized along.</p>
<dl class="docutils">
<dt><em>args</em>: </dt>
<dd><ul class="first last">
<li><p class="first"><strong>Kdic</strong>: dictionary for generation of kpath with:</p>
<blockquote>
<div><ul class="simple">
<li><em>‘type’</em>: string ‘A’ (absolute) or ‘F’ (fractional) units</li>
<li><em>‘avec’</em>: numpy array of 3x3 float lattice vectors</li>
<li><em>‘pts’</em>: list of len3 array indicating the high-symmetry points</li>
</ul>
<p>along the path of interest</p>
<ul class="simple">
<li><em>‘grain’</em>: int, number of points between <em>each</em> element of <em>‘pts’</em></li>
</ul>
<p>optional:</p>
<blockquote>
<div><ul class="simple">
<li><em>‘labels’</em>:list of strings with same length as <em>‘pts’</em>, giving</li>
</ul>
<p>plotting labels for the kpath</p>
</div></blockquote>
</div></blockquote>
</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><strong>Kobj</strong>: K-object including necessary attributes to be read by the <strong>TB_model</strong></dd>
</dl>
<p><a href="#id1"><span class="problematic" id="id2">**</span></a><a href="#id3"><span class="problematic" id="id4">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.build_lib.gen_TB">
<code class="descclassname">chinook.build_lib.</code><code class="descname">gen_TB</code><span class="sig-paren">(</span><em>basis_dict</em>, <em>hamiltonian_dict</em>, <em>Kobj=None</em>, <em>slab_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.build_lib.gen_TB" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a Tight-Binding Model using the user-input dictionaries</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first simple">
<li><strong>basis_dict</strong>: dictionary, including the <em>‘bulk’</em> key value pair</li>
</ul>
<p>generated by <strong>gen_basis</strong></p>
<ul class="last">
<li><p class="first"><strong>hamiltonian_dict</strong>: dictionary,</p>
<blockquote>
<div><ul class="simple">
<li><em>‘spin’</em>: same dictionary as passed to <strong>gen_basis</strong></li>
<li><em>‘type’</em>: string, Hamiltonian type–’list’ (list of matrix elements),</li>
</ul>
<p>‘SK’ (Slater-Koster dictionaries, requires also a ‘V’ and ‘avec’ entry),
‘txt’ (textfile, requires a ‘filename’ key as well)</p>
<ul class="simple">
<li><em>‘cutoff’</em>: float, cutoff hopping distance</li>
<li><em>‘renorm’</em>: float, renormalization factor</li>
<li><em>‘offset’</em>: float, offset of chemical potential</li>
<li><em>‘tol’</em>: float, minimum matrix element tolerance</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>Kobj</strong>: optional, standard K-object, as generated by <strong>gen_K</strong></p>
</li>
<li><p class="first"><strong>slab_dict</strong>: dictionary for slab generation</p>
<blockquote>
<div><ul class="simple">
<li><em>‘avec’</em>: numpy array of 3x3 float, lattice vectors</li>
<li><em>‘miller’</em>: numpy array of 3 integers, indicating the Miller</li>
</ul>
<p>index of the surface normal in units of lattice vectors</p>
<ul class="simple">
<li><em>‘fine’</em>: fine adjustment of the slab thickness, tuple of two</li>
</ul>
<p>numeric to get desired termination correct (for e.g. inversion symmetry)</p>
<ul class="simple">
<li><em>‘thick’</em>: integer approximate number of unit cells in the</li>
</ul>
<p>slab (will not be exact, depending on the fine, and termination</p>
<ul class="simple">
<li><em>‘vac’</em>: int size of the vacuum buffer – must be larger than</li>
</ul>
<p>the largest hopping length to ensure no coupling of slabs</p>
<ul class="simple">
<li><em>‘termination’</em>: tuple of 2 integers: atom indices which</li>
</ul>
<p>terminate the top and bottom of the slab</p>
</div></blockquote>
</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><strong>TB_model</strong>: tight-binding object, as defined in <strong>chinook.TB_lib.py</strong></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="chinook.build_lib.gen_basis">
<code class="descclassname">chinook.build_lib.</code><code class="descname">gen_basis</code><span class="sig-paren">(</span><em>basis</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.build_lib.gen_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a list of orbital objects as the input basis for a tight-binding model.
User passes a basis dictionary, function returns a modified version of this
same dictionary, with the list of orbitals now appended as the <em>‘bulk’</em> entry</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last">
<li><p class="first"><strong>basis</strong>–dictionary with keys:</p>
<blockquote>
<div><ul class="simple">
<li><em>‘atoms’</em>: list of integer, indices for distinct atoms,</li>
<li><em>‘Z’</em>: dictionary of integer: <em>‘atom’</em>:element (integer) pairs</li>
<li><em>‘orbs’</em>: list of lists of string, for each atom containing the</li>
</ul>
<p>orbital labels (usually in conventional nlxx format)),</p>
<ul class="simple">
<li><em>‘pos’</em>: list of numpy arrays of length 3 float indicating</li>
</ul>
<p>positions of the atoms in direct Angstrom units,</p>
<ul>
<li><p class="first">optional keys:</p>
<blockquote>
<div><ul class="simple">
<li><em>‘orient’</em>: list, one entry for each atom, indicating a</li>
</ul>
<p>local rotation of the indicated atom, various formats accepted; 
for more details, c.f. <strong>chinook.orbital.py</strong></p>
<ul>
<li><p class="first"><em>‘spin’</em>: dictionary of spin information:</p>
<blockquote>
<div><ul class="simple">
<li><em>‘bool’</em>: boolean, double basis into spinor basis,</li>
<li><em>‘soc’</em>: boolean, include spin-orbit coupling</li>
<li><em>‘lam’</em>: dictionary of SOC constants, integer:float</li>
</ul>
<p>pairs for atoms in <em>‘atoms’</em> list, and lambda_SOC in eV</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first simple">
<li><strong>basis</strong> dictionary, modified to include the <strong>bulk</strong> list of orbital</li>
</ul>
<p class="last">objects</p>
</dd>
</dl>
<p><a href="#id5"><span class="problematic" id="id6">**</span></a><a href="#id7"><span class="problematic" id="id8">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.build_lib.recur_product">
<code class="descclassname">chinook.build_lib.</code><code class="descname">recur_product</code><span class="sig-paren">(</span><em>elements</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.build_lib.recur_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function: Recursive evaluation of the product of all elements in a list</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>elements</strong>: list of numeric type</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li>product of all elements of <strong>elements</strong></li>
</ul>
</dd>
</dl>
<p><a href="#id9"><span class="problematic" id="id10">**</span></a><a href="#id11"><span class="problematic" id="id12">*</span></a></p>
</dd></dl>

</div>
<div class="section" id="module-chinook.H_library">
<span id="h-library"></span><h2>H_library:<a class="headerlink" href="#module-chinook.H_library" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="chinook.H_library.AFM_order">
<code class="descclassname">chinook.H_library.</code><code class="descname">AFM_order</code><span class="sig-paren">(</span><em>basis</em>, <em>dS</em>, <em>p_up</em>, <em>p_dn</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.H_library.AFM_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Add antiferromagnetism to the tight-binding model, by adding a different on-site energy to 
orbitals of different spin character, on the designated sites.</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first simple">
<li><strong>basis</strong>: list, orbital objects</li>
<li><strong>dS</strong>: float, size of spin-splitting (eV)</li>
<li><strong>p_up</strong>, <strong>p_dn</strong>: numpy array of float indicating the orbital positions</li>
</ul>
<p class="last">for the AFM order</p>
</dd>
<dt><em>return</em>: </dt>
<dd><ul class="first last simple">
<li><strong>h_AF</strong>: list of matrix elements, as conventionally arranged [[o1,o2,0,0,0,H12],…]</li>
</ul>
</dd>
</dl>
<p><a href="#id13"><span class="problematic" id="id14">**</span></a><a href="#id15"><span class="problematic" id="id16">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.H_library.FM_order">
<code class="descclassname">chinook.H_library.</code><code class="descname">FM_order</code><span class="sig-paren">(</span><em>basis</em>, <em>dS</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.H_library.FM_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Add ferromagnetism to the system. Take dS to assume that the splitting puts 
spin-up lower in energy by dS,and viceversa for spin-down. This directly
modifies the <em>TB_model</em>’s <strong>mat_els</strong> attribute</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>basis</strong>: list, of orbital objects in basis</li>
<li><strong>dS</strong>: float, energy of the spin splitting (eV)</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li>list of matrix elements [[o1,o2,0,0,0,H12],…]</li>
</ul>
</dd>
</dl>
<p><a href="#id17"><span class="problematic" id="id18">**</span></a><a href="#id19"><span class="problematic" id="id20">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.H_library.Lm">
<code class="descclassname">chinook.H_library.</code><code class="descname">Lm</code><span class="sig-paren">(</span><em>l</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.H_library.Lm" title="Permalink to this definition">¶</a></dt>
<dd><p>L- operator in the l,m_l basis, organized with 
(0,0) = <a href="#id21"><span class="problematic" id="id22">|</span></a>l,l&gt;… (2l,2l) = <a href="#id23"><span class="problematic" id="id24">|</span></a>l,-l&gt;</p>
<p>The nonzero elements are on the upper diagonal</p>
<dl class="docutils">
<dt><em>arg</em>:</dt>
<dd><ul class="first last simple">
<li><strong>l</strong>: int orbital angular momentum</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>M</strong>: numpy array (2l+1,2l+1) of real float</li>
</ul>
</dd>
</dl>
<p><a href="#id25"><span class="problematic" id="id26">**</span></a><a href="#id27"><span class="problematic" id="id28">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.H_library.Lp">
<code class="descclassname">chinook.H_library.</code><code class="descname">Lp</code><span class="sig-paren">(</span><em>l</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.H_library.Lp" title="Permalink to this definition">¶</a></dt>
<dd><p>L+ operator in the <span class="math notranslate nohighlight">\(l\)</span>, <span class="math notranslate nohighlight">\(m_l\)</span> basis, organized with 
(0,0) = <a href="#id29"><span class="problematic" id="id30">|</span></a>l,l&gt;… (2l,2l) = <a href="#id31"><span class="problematic" id="id32">|</span></a>l,-l&gt;
The nonzero elements are on the upper diagonal</p>
<dl class="docutils">
<dt><em>arg</em>:</dt>
<dd><ul class="first last simple">
<li><strong>l</strong>: int orbital angular momentum</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>M</strong>: numpy array (2l+1,2l+1) of real float</li>
</ul>
</dd>
</dl>
<p><a href="#id33"><span class="problematic" id="id34">**</span></a><a href="#id35"><span class="problematic" id="id36">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.H_library.Lz">
<code class="descclassname">chinook.H_library.</code><code class="descname">Lz</code><span class="sig-paren">(</span><em>l</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.H_library.Lz" title="Permalink to this definition">¶</a></dt>
<dd><p>Lz operator in the l,:math:<cite>m_l</cite> basis</p>
<dl class="docutils">
<dt><em>arg</em>:</dt>
<dd><ul class="first last simple">
<li><strong>l</strong>: int orbital angular momentum</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li>numpy array (2*l+1,2*l+1)</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="chinook.H_library.SO">
<code class="descclassname">chinook.H_library.</code><code class="descname">SO</code><span class="sig-paren">(</span><em>basis</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.H_library.SO" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate L.S  matrix-elements for a given basis. 
This is generic to all l, except the normal_order, which is defined here up to 
and including the f electrons.
Otherwise, this method is generic to any orbital angular momentum.</p>
<p>In the factors dictionary defined here indicates the weight of the 
different <span class="math notranslate nohighlight">\(L_iS_i\)</span> terms. The keys are tuples of (L+/-/z,S+/-/z)
in a bit of a cryptic way: for L, (0,1,2) -&gt;(-1,0,1) and
for S, (-1,0,1) = S1-S2 with S1,2 = +/- 1 here</p>
<p>L+,L-,Lz matrices are defined for each l shell in the basis, 
transformed into the basis of the tight-binding model.
The nonzero terms will then just be used along with the spin and
weighted by the factor value, and slotted into a len(<strong>basis</strong>)xlen(<strong>basis</strong>) matrix <strong>HSO</strong></p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>basis</strong>: list of orbital objects</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>HSO</strong>: list of matrix elements in standard format [o1,o2,0,0,0,H12]</li>
</ul>
</dd>
</dl>
<p><a href="#id37"><span class="problematic" id="id38">**</span></a><a href="#id39"><span class="problematic" id="id40">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.H_library.Vlist_gen">
<code class="descclassname">chinook.H_library.</code><code class="descname">Vlist_gen</code><span class="sig-paren">(</span><em>V</em>, <em>pair</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.H_library.Vlist_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Select the relevant hopping matrix elements to be used in defining the value
of the Slater-Koster matrix elements for a given pair of orbitals</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>V</strong>: dictionary of Slater-Koster hopping terms</li>
<li><strong>pair</strong>: tuple of int defining the orbitals to be paired, (a1,a2,n1,n2,l1,l2)</li>
</ul>
</dd>
</dl>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><strong>Vvals</strong>: numpy array of Vllx related to a given pairing, e.g. for s-p np.array([Vsps,Vspp])</li>
</ul>
</div></blockquote>
<p><a href="#id41"><span class="problematic" id="id42">**</span></a><a href="#id43"><span class="problematic" id="id44">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.H_library.cluster_init">
<code class="descclassname">chinook.H_library.</code><code class="descname">cluster_init</code><span class="sig-paren">(</span><em>Vdict</em>, <em>cutoff</em>, <em>avec</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.H_library.cluster_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a cluster of neighbouring lattice points to use
in defining the hopping paths–ensuring that it extends
sufficiently far enough to capture even the largest hopping vectors.
Also reforms the SK dictionary and cutoff lengths to be in list format.
Returns an array of lattice points which go safely to the edge of the cutoff range.</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>Vdict</strong>: dictionary, or list of dictionaries of Slater Koster matrix elements</li>
<li><strong>cutoff</strong>: float, or list of float</li>
<li><strong>avec</strong>: numpy array of 3x3 float</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first simple">
<li><strong>Vdict</strong>: list of length 1 if a single dictionary passed, else unmodified</li>
<li><strong>cutoff</strong>: numpy array, append 0 to the beginning of the cutoff list,</li>
</ul>
<p>else leave it alone.</p>
<ul class="simple">
<li><strong>pts</strong>: numpy array of lattice vector indices for a region of lattice points around</li>
</ul>
<p class="last">the origin.</p>
</dd>
</dl>
<p><a href="#id45"><span class="problematic" id="id46">**</span></a><a href="#id47"><span class="problematic" id="id48">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.H_library.index_ordering">
<code class="descclassname">chinook.H_library.</code><code class="descname">index_ordering</code><span class="sig-paren">(</span><em>basis</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.H_library.index_ordering" title="Permalink to this definition">¶</a></dt>
<dd><p>We use an universal ordering convention for defining the Slater-Koster matrices
which may (and most likely will) not match the ordering chosen by the user.
To account for this, we define a dictionary which gives the ordering, relative 
to the normal order convention defined here, associated with a given a-n-l shell
at each site in the lattice basis.</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>basis</strong>: list of orbital objects</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>indexing</strong>: dictionary of key-value pairs (a,n,l,x,y,z):numpy.array([…])</li>
</ul>
</dd>
</dl>
<p><a href="#id49"><span class="problematic" id="id50">**</span></a><a href="#id51"><span class="problematic" id="id52">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.H_library.mat_els">
<code class="descclassname">chinook.H_library.</code><code class="descname">mat_els</code><span class="sig-paren">(</span><em>Rij</em>, <em>SKmat</em>, <em>tol</em>, <em>i1</em>, <em>i2</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.H_library.mat_els" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the pertinent, and non-zero elements of the Slater-Koster matrix
and transform to the conventional form of Hamiltonian list entries
(o1,o2,Rij0,Rij1,Rij2,H12(Rij))</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first simple">
<li><strong>Rij</strong>: numpy array of 3 float, relevant connecting vector</li>
<li><strong>SKmat</strong>: numpy array of float, matrix of hopping elements</li>
</ul>
<p>for the coupling of two orbital shells</p>
<ul class="simple">
<li><strong>tol</strong>: float, minimum hopping included in model</li>
<li><strong>i1</strong>, <strong>i2</strong>: int,int, proper index ordering for the relevant</li>
</ul>
<p class="last">instance of the orbital shells involved in hopping</p>
</dd>
</dl>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><strong>out</strong>: list of Hamiltonian matrix elements, extracted from the</li>
</ul>
<p>ordered SKmat, in form [[o1,o2,x12,y12,z12,H12],…]</p>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="chinook.H_library.mirror_SK">
<code class="descclassname">chinook.H_library.</code><code class="descname">mirror_SK</code><span class="sig-paren">(</span><em>SK_in</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.H_library.mirror_SK" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a list of values which is the input appended with its mirror 
reflection. The mirror boundary condition suppresses the duplicate of the
last value. e.g. [0,1,2,3,4] –&gt; [0,1,2,3,4,3,2,1,0], 
[‘r’,’a’,’c’,’e’,’c’,’a’,’r’] –&gt; [‘r’,’a’,’c’,’e’,’c’,’a’,’r’,’a’,’c’,’e’,’c’,’a’,’r’]
Intended here to take an array of Slater-Koster hopping terms and reflect about 
its last entry i.e. [Vsps,Vspp] -&gt; [Vsps,Vspp,Vsps]</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>SK_in</strong>: iterable, of arbitrary length and data-type</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li>list of values with same data-type as input</li>
</ul>
</dd>
</dl>
<p><a href="#id53"><span class="problematic" id="id54">**</span></a><a href="#id55"><span class="problematic" id="id56">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.H_library.on_site">
<code class="descclassname">chinook.H_library.</code><code class="descname">on_site</code><span class="sig-paren">(</span><em>basis</em>, <em>V</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.H_library.on_site" title="Permalink to this definition">¶</a></dt>
<dd><p>On-site matrix element calculation. Try both anl and alabel formats,
if neither is defined, default the onsite energy to 0.0 eV</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>basis</strong>: list of orbitals defining the tight-binding basis</li>
<li><strong>V</strong>: dictionary, Slater Koster terms</li>
<li><strong>offset</strong>: float, EF shift</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>Ho</strong>: list of Hamiltonian matrix elements</li>
</ul>
</dd>
</dl>
<p><a href="#id57"><span class="problematic" id="id58">**</span></a><a href="#id59"><span class="problematic" id="id60">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.H_library.region">
<code class="descclassname">chinook.H_library.</code><code class="descname">region</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.H_library.region" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a symmetric grid of points in number of lattice vectors.</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>num</strong>: int, grid will have size 2*num+1 in each direction</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first simple">
<li>numpy array of size ((2*num+1)**3,3) with centre value of first entry</li>
</ul>
<p class="last">of (-num,-num,-num),…,(0,0,0),…,(num,num,num)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="chinook.H_library.sk_build">
<code class="descclassname">chinook.H_library.</code><code class="descname">sk_build</code><span class="sig-paren">(</span><em>avec</em>, <em>basis</em>, <em>Vdict</em>, <em>cutoff</em>, <em>tol</em>, <em>renorm</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.H_library.sk_build" title="Permalink to this definition">¶</a></dt>
<dd><p>Build SK model from using D-matrices, rather than a list of SK terms from table.
This can handle orbitals of arbitrary orbital angular momentum in principal, 
but right now implemented for up to and including f-electrons. 
NOTE: f-hoppings require thorough testing</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>avec</strong>: numpy array 3x3 float, lattice vectors</li>
<li><strong>basis</strong>: list of orbital objects</li>
<li><strong>Vdict</strong>: dictionary, or list of dictionaries, of Slater-Koster integrals/ on-site energies</li>
<li><strong>cutoff</strong>: float or list of float, indicating range where Vdict is applicable</li>
<li><strong>tol</strong>: float, threshold value below which hoppings are neglected</li>
<li><strong>offset</strong>: float, offset for Fermi level</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>H_raw</strong>: list of Hamiltonian matrix elements, in form [o1,o2,x12,y12,z12,t12]</li>
</ul>
</dd>
</dl>
<p><a href="#id61"><span class="problematic" id="id62">**</span></a><a href="#id63"><span class="problematic" id="id64">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.H_library.spin_double">
<code class="descclassname">chinook.H_library.</code><code class="descname">spin_double</code><span class="sig-paren">(</span><em>H</em>, <em>lb</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.H_library.spin_double" title="Permalink to this definition">¶</a></dt>
<dd><p>Duplicate the kinetic Hamiltonian terms to extend over the spin-duplicated 
orbitals, which are by construction in same order and appended to end of the
original basis.</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>H</strong>: list, Hamiltonian matrix elements [[o1,o2,x,y,z,H12],…]</li>
<li><strong>lb</strong>: int, length of basis before spin duplication</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first simple">
<li><strong>h2</strong> modified copy of <strong>H</strong>, filled with kinetic terms for both</li>
</ul>
<p class="last">spin species</p>
</dd>
</dl>
<p><a href="#id65"><span class="problematic" id="id66">**</span></a><a href="#id67"><span class="problematic" id="id68">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.H_library.txt_build">
<code class="descclassname">chinook.H_library.</code><code class="descname">txt_build</code><span class="sig-paren">(</span><em>filename</em>, <em>cutoff</em>, <em>renorm</em>, <em>offset</em>, <em>tol</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.H_library.txt_build" title="Permalink to this definition">¶</a></dt>
<dd><p>Build Hamiltonian from textfile, input is of form
o1,o2,x12,xy12,z12,t12, output in form [o1,o2,x12,y12,z12,t12]</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>filename</strong>: string, name of file</li>
<li><strong>cutoff</strong>: float, maximum distance of hopping allowed, Angstrom</li>
<li><strong>renorm</strong>: float, renormalization of the bandstructure</li>
<li><strong>offset</strong>: float, energy offset of chemical potential, electron volts</li>
<li><strong>tol</strong>: float, minimum Hamiltonian matrix element amplitude</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>Hlist</strong>: the list of Hamiltonian matrix elements</li>
</ul>
</dd>
</dl>
<p><a href="#id69"><span class="problematic" id="id70">**</span></a><a href="#id71"><span class="problematic" id="id72">*</span></a></p>
</dd></dl>

</div>
<div class="section" id="module-chinook.klib">
<span id="klib"></span><h2>klib:<a class="headerlink" href="#module-chinook.klib" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="chinook.klib.b_zone">
<code class="descclassname">chinook.klib.</code><code class="descname">b_zone</code><span class="sig-paren">(</span><em>a_vec</em>, <em>N</em>, <em>show=False</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.klib.b_zone" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a mesh of points over the Brillouin zone. 
Each of the cardinal axes are divided by the same number of points 
(so points are not necessarily evenly spaced along each axis).</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>a_vec</strong>: numpy array of size 3x3 float</li>
<li><strong>N</strong>: int mesh density</li>
</ul>
</dd>
<dt><em>kwargs</em>:     </dt>
<dd><ul class="first last simple">
<li><strong>show</strong>: boolean for optional plotting of the mesh points</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>m_pts</strong>: numpy array of mesh points (float), shape (len(m_pts),3)</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="chinook.klib.bvectors">
<code class="descclassname">chinook.klib.</code><code class="descname">bvectors</code><span class="sig-paren">(</span><em>a_vec</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.klib.bvectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the reciprocal lattice vectors corresponding to the direct lattice 
in real space</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>a_vec</strong>: numpy array of 3x3 float, lattice vectors</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>b_vec</strong>: numpy array of 3x3 float, reciprocal lattice vectors</li>
</ul>
</dd>
</dl>
<p><a href="#id73"><span class="problematic" id="id74">**</span></a><a href="#id75"><span class="problematic" id="id76">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.klib.kmesh">
<code class="descclassname">chinook.klib.</code><code class="descname">kmesh</code><span class="sig-paren">(</span><em>ang</em>, <em>X</em>, <em>Y</em>, <em>kz</em>, <em>Vo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.klib.kmesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a mesh of kx and ky with fixed kz and generate a Nx3 array of points
which rotates the mesh about the z axis by <strong>ang</strong>. N is the flattened shape
of <strong>X</strong> and <strong>Y</strong>.</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>ang</strong>: float, angle of rotation</li>
<li><strong>X</strong>: numpy array of float, one coordinate of meshgrid</li>
<li><strong>Y</strong>: numpy array of float, second coordinate of meshgrid</li>
<li><strong>kz</strong>: float, third dimension of momentum path, fixed</li>
</ul>
</dd>
<dt><em>kwargs</em>:</dt>
<dd><ul class="first last simple">
<li><strong>Vo</strong>: parameters necessary for inclusion of inner potential</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first simple">
<li><strong>k_arr</strong>: numpy array of shape Nx3 float, rotated  kpoint array.</li>
<li><strong>ph</strong>: numpy array of N float, angles of the in-plane momentum</li>
</ul>
<p class="last">points, before rotation.</p>
</dd>
</dl>
<p><a href="#id77"><span class="problematic" id="id78">**</span></a><a href="#id79"><span class="problematic" id="id80">*</span></a></p>
</dd></dl>

<dl class="class">
<dt id="chinook.klib.kpath">
<em class="property">class </em><code class="descclassname">chinook.klib.</code><code class="descname">kpath</code><span class="sig-paren">(</span><em>pts</em>, <em>grain=None</em>, <em>labels=None</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.klib.kpath" title="Permalink to this definition">¶</a></dt>
<dd><p>Momentum object, defining a path in reciprocal space, for use in defining the 
Hamiltonian at different points in the Brillouin zone.
<a href="#id81"><span class="problematic" id="id82">**</span></a><a href="#id83"><span class="problematic" id="id84">*</span></a></p>
<dl class="method">
<dt id="chinook.klib.kpath.points">
<code class="descname">points</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chinook.klib.kpath.points" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the endpoints of kpath defined in <strong>kpath.pts</strong> to create numpy array
of len(3) float which cover the entire path, based on method by I.S. Elfimov.</p>
<dl class="docutils">
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>kpath.kpts</strong>: numpy array of float, len(<strong>kpath.pts</strong>)(1+**kpath.grain**) by 3</li>
</ul>
</dd>
</dl>
<p><a href="#id85"><span class="problematic" id="id86">**</span></a><a href="#id87"><span class="problematic" id="id88">*</span></a></p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="chinook.klib.kz_kpt">
<code class="descclassname">chinook.klib.</code><code class="descname">kz_kpt</code><span class="sig-paren">(</span><em>hv</em>, <em>kpt</em>, <em>W</em>, <em>V</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.klib.kz_kpt" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the kz associated with a given in-plane momentum, photon energy, 
work function and inner potential</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>hv</strong>: float, photon energ in eV</li>
<li><strong>kpt</strong>: float, in plane momentum, inverse Angstrom</li>
<li><strong>W</strong>: float, work function in eV</li>
<li><strong>V</strong>: float, inner potential in eV</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>kz</strong>: float, out of plane momentum, inverse Angstrom</li>
</ul>
</dd>
</dl>
<p><a href="#id89"><span class="problematic" id="id90">**</span></a><a href="#id91"><span class="problematic" id="id92">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.klib.mesh_reduce">
<code class="descclassname">chinook.klib.</code><code class="descname">mesh_reduce</code><span class="sig-paren">(</span><em>blatt</em>, <em>mesh</em>, <em>inds=False</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.klib.mesh_reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine and select only k-points corresponding to the first Brillouin
zone, by simply classifying points on the basis
of whether or not the closest lattice point is the origin. 
By construction, the origin is index 13 of the blatt. 
If it is not, return error. Option to take only the indices of
the mesh which we want, rather than the actual array points
–this is relevant for tetrahedral interpolation methods</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first simple">
<li><strong>blatt</strong>: numpy array of len(27,3), nearest reciprocal lattice vector points</li>
<li><strong>mesh</strong>: numpy array of (N,3) float, defining a mesh of k points, before</li>
</ul>
<p class="last">being reduced to contain only the Brillouin zone.</p>
</dd>
<dt><em>kwargs</em>: </dt>
<dd><ul class="first simple">
<li><strong>inds</strong>: option to pass a list of bool, indicating the</li>
</ul>
<p class="last">indices one wants to keep, instead of autogenerating the mesh</p>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>bz_pts</strong>: numpy array of (M,3) float, Brillouin zone points</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="chinook.klib.plt_pts">
<code class="descclassname">chinook.klib.</code><code class="descname">plt_pts</code><span class="sig-paren">(</span><em>pts</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.klib.plt_pts" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot an array of points iin 3D</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>pts</strong>: numpy array shape N x 3</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="chinook.klib.raw_mesh">
<code class="descclassname">chinook.klib.</code><code class="descname">raw_mesh</code><span class="sig-paren">(</span><em>blatt</em>, <em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.klib.raw_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a mesh of points filling the region of k-space bounded by the set
of reciprocal lattice points generated by <em>bvectors</em>.
These will be further reduced by <em>mesh_reduce</em> to find points which
are within the first-Brillouin zone</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first simple">
<li><strong>blatt</strong>: numpy array of 27x3 float</li>
<li><strong>N</strong>: int, or iterable of len 3, defines a coarse estimation</li>
</ul>
<p class="last">of number of k-points</p>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>mesh</strong>: numpy array of mesh points, size set roughly by N</li>
</ul>
</dd>
</dl>
<p><a href="#id93"><span class="problematic" id="id94">**</span></a><a href="#id95"><span class="problematic" id="id96">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.klib.region">
<code class="descclassname">chinook.klib.</code><code class="descname">region</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.klib.region" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a symmetric grid of points in number of lattice vectors.</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>num</strong>: int, grid will have size 2 num+1 in each direction</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first simple">
<li>numpy array of size ((2 num+1)**3,3) with centre value of</li>
</ul>
<p class="last">first entry of (-num,-num,-num),…,(0,0,0),…,(num,num,num)</p>
</dd>
</dl>
<p><a href="#id97"><span class="problematic" id="id98">**</span></a><a href="#id99"><span class="problematic" id="id100">*</span></a></p>
</dd></dl>

</div>
<div class="section" id="module-chinook.orbital">
<span id="orbital"></span><h2>orbital:<a class="headerlink" href="#module-chinook.orbital" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="chinook.orbital.fact">
<code class="descclassname">chinook.orbital.</code><code class="descname">fact</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.orbital.fact" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursive factorial function, works for any non-negative integer.</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>n</strong>: int, or integer-float</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li>int, recursively evaluates the factorial of the initial input value.</li>
</ul>
</dd>
</dl>
<p><a href="#id101"><span class="problematic" id="id102">**</span></a><a href="#id103"><span class="problematic" id="id104">*</span></a></p>
</dd></dl>

<dl class="class">
<dt id="chinook.orbital.orbital">
<em class="property">class </em><code class="descclassname">chinook.orbital.</code><code class="descname">orbital</code><span class="sig-paren">(</span><em>atom, index, label, pos, Z, orient=[0.0], spin=1, lam=0.0, sigma=1.0, slab_index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.orbital.orbital" title="Permalink to this definition">¶</a></dt>
<dd><p>The <strong>orbital</strong> object carries all essential details of the elements of the
model Hamiltonian basis, for both generation of the tight-binding model, in
addition to the evaluation of expectation values and ARPES intensity.</p>
<dl class="method">
<dt id="chinook.orbital.orbital.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chinook.orbital.orbital.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy by value method for orbital object</p>
<dl class="docutils">
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>orbital_copy</strong>: duplicate of <strong>orbital</strong> object</li>
</ul>
</dd>
</dl>
<p><a href="#id105"><span class="problematic" id="id106">**</span></a><a href="#id107"><span class="problematic" id="id108">*</span></a></p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="chinook.orbital.rot_projection">
<code class="descclassname">chinook.orbital.</code><code class="descname">rot_projection</code><span class="sig-paren">(</span><em>l</em>, <em>proj</em>, <em>rotation</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.orbital.rot_projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Go through a projection array, and apply the intended transformation to
the Ylm projections in order.
Define Euler angles in the z-y-z convention
THIS WILL BE A COUNTERCLOCKWISE ROTATION ABOUT a vector BY angle gamma 
expressed in radians. Note that we always define spin in the lab-frame, so
spin degrees of freedom are not rotated when we rotate the orbital degrees
of freedom.</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first simple">
<li><strong>l</strong>: int,orbital angular momentum</li>
<li><strong>proj</strong>: numpy array of shape Nx4 of float, each element is</li>
</ul>
<p>[Re(projection),Im(projection),l,m]</p>
<ul class="simple">
<li><strong>rotation</strong>: float, or list, defining rotation of orbital. If float,</li>
</ul>
<p class="last">assume rotation about z-axis. If list, first element is a numpy array 
of len 3, indicating rotation vector, and second element is float, angle.</p>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first simple">
<li><strong>proj</strong>: numpy array of Mx4 float, as above, but modified, and may</li>
</ul>
<p>now include additional, or fewer elements than input <em>proj</em>.</p>
<ul class="simple">
<li><strong>Dmat</strong>: numpy array of (2l+1)x(2l+1) complex float indicating the</li>
</ul>
<p class="last">Wigner Big-D matrix associated with the rotation of this orbital shell
about the intended axis.</p>
</dd>
</dl>
<p><a href="#id109"><span class="problematic" id="id110">**</span></a><a href="#id111"><span class="problematic" id="id112">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.orbital.slab_basis_copy">
<code class="descclassname">chinook.orbital.</code><code class="descname">slab_basis_copy</code><span class="sig-paren">(</span><em>basis</em>, <em>new_posns</em>, <em>new_inds</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.orbital.slab_basis_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy elements of a slab basis into a new list of
orbitals, with modified positions and index ordering.</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first simple">
<li><strong>basis</strong>: list or orbital objects</li>
<li><strong>new_posns</strong>: numpy array of len(basis)x3 float, new positions for</li>
</ul>
<p>orbital</p>
<ul class="last simple">
<li><strong>new_inds</strong>: numpy array of len(basis) int, new indices for orbitals</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>new_basis</strong>: list of duplicated orbitals following modification.</li>
</ul>
</dd>
</dl>
<p><a href="#id113"><span class="problematic" id="id114">**</span></a><a href="#id115"><span class="problematic" id="id116">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.orbital.sort_basis">
<code class="descclassname">chinook.orbital.</code><code class="descname">sort_basis</code><span class="sig-paren">(</span><em>basis</em>, <em>slab</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.orbital.sort_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility script for organizing an orbital basis that is out of sequence</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>basis</strong>: list of orbital objects</li>
<li><strong>slab</strong>: bool, True or False if this is for sorting a slab</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>orb_basis</strong>: list of sorted orbital objects (by orbital.index value)</li>
</ul>
</dd>
</dl>
<p><a href="#id117"><span class="problematic" id="id118">**</span></a><a href="#id119"><span class="problematic" id="id120">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.orbital.spin_double">
<code class="descclassname">chinook.orbital.</code><code class="descname">spin_double</code><span class="sig-paren">(</span><em>basis</em>, <em>lamdict</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.orbital.spin_double" title="Permalink to this definition">¶</a></dt>
<dd><p>Double the size of a basis to introduce spin to the problem.
Go through the basis and create an identical copy with opposite spin and 
incremented index such that the orbital basis order puts spin down in the first
N/2 orbitals, and spin up in the second N/2.</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first simple">
<li><strong>basis</strong>: list of orbital objects</li>
<li><strong>lamdict</strong>: dictionary of int:float pairs providing the</li>
</ul>
<p class="last">spin-orbit coupling strength for the different inequivalent atoms in 
basis.</p>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li>doubled basis carrying all required spin information</li>
</ul>
</dd>
</dl>
<p><a href="#id121"><span class="problematic" id="id122">**</span></a><a href="#id123"><span class="problematic" id="id124">*</span></a></p>
</dd></dl>

</div>
<div class="section" id="module-chinook.SlaterKoster">
<span id="slaterkoster"></span><h2>SlaterKoster:<a class="headerlink" href="#module-chinook.SlaterKoster" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="chinook.SlaterKoster.SK_cub">
<code class="descclassname">chinook.SlaterKoster.</code><code class="descname">SK_cub</code><span class="sig-paren">(</span><em>Ymats</em>, <em>l1</em>, <em>l2</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.SlaterKoster.SK_cub" title="Permalink to this definition">¶</a></dt>
<dd><p>In order to generate a set of independent Lambda functions for rapid 
generation of Hamiltonian matrix elements, one must nest the 
definition of the lambda functions within another function. In this way,
we avoid cross-contamination of unrelated functions.
The variables which are fixed for a given lambda function are the 
cubic -to- spherical harmonics (Ymat) transformations, and the 
orbital angular momentum of the relevant basis channels. The output
lambda functions will be functions of the Euler-angles pertaining 
to the hopping path, as well as the potential matrix V, which will be
passed as a numpy array (min(l1,l2)*2+1) long of float.</p>
<p>We follow the method described for rotated d-orbitals in the thesis of
JM Carter from Toronto (HY Kee), where the Slater-Koster hopping
matrix can be defined as the following operation:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Transform local orbital basis into spherical harmonics</li>
<li>Rotate the hopping path along the z-axis</li>
<li>Product with the diagonal SK-matrix</li>
<li>Rotate the path backwards</li>
<li>Rotate back into basis of local orbitals</li>
</ol>
<p>6. Output matrix of hopping elements between all orbitals in the shell 
to fill Hamiltonian</p>
</div></blockquote>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first simple">
<li><strong>Ymats</strong>: list of numpy arrays corresponding to the relevant</li>
</ul>
<p>transformation from cubic to spherical harmonic basis</p>
<ul class="simple">
<li><strong>l1</strong>, <strong>l2</strong>: int orbital angular momentum channels relevant</li>
</ul>
<p class="last">to a given hopping pair</p>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first simple">
<li>lambda function for the SK-matrix between these orbital shells,</li>
</ul>
<p class="last">for arbitrary hopping strength and direction.</p>
</dd>
</dl>
<p><a href="#id125"><span class="problematic" id="id126">**</span></a><a href="#id127"><span class="problematic" id="id128">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.SlaterKoster.SK_full">
<code class="descclassname">chinook.SlaterKoster.</code><code class="descname">SK_full</code><span class="sig-paren">(</span><em>basis</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.SlaterKoster.SK_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a dictionary of lambda functions which take as keys the
atom,orbital for both first and second element. 
Formatting is a1a2n1n2l1l2, same as for SK dictionary entries</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>basis</strong>: list of orbital objects composing the TB-basis</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first simple">
<li><strong>SK_funcs</strong>: a dictionary of hopping matrix functions</li>
</ul>
<p class="last">(lambda functions with args EA,EB,Ey,V as Euler angles and potential (V))
which can be executed for various hopping paths and potential strengths
The keys of the dictionary will be organized similar to the way the SK
parameters are passed, labelled by a1a2n1n2l1l2, which completely
defines a given orbital-orbital coupling</p>
</dd>
</dl>
<p><a href="#id129"><span class="problematic" id="id130">**</span></a><a href="#id131"><span class="problematic" id="id132">*</span></a></p>
</dd></dl>

<dl class="function">
<dt id="chinook.SlaterKoster.Vmat">
<code class="descclassname">chinook.SlaterKoster.</code><code class="descname">Vmat</code><span class="sig-paren">(</span><em>l1</em>, <em>l2</em>, <em>V</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.SlaterKoster.Vmat" title="Permalink to this definition">¶</a></dt>
<dd><p>For Slater-Koster matrix element generation, a potential matrix is
sandwiched in between the two bond-rotating Dmatrices. It should be 
of the shape 2*l1+1 x 2*l2+1, and have the V_l,l’,D terms along the 
‘diagonal’– a concept that is only well defined for a square matrix.
For mismatched angular momentum channels, this turns into a diagonal 
square matrix of dimension min(2*l1+1,2*l2+1) centred  along the larger
axis. For channels where the orbital angular momentum change involves a
change in parity, the potential should change sign, as per Slater Koster’s
original definition from 1954. This is taken care of automatically in 
the Wigner formalism I use here, no need to have exceptions</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>l1</strong>, <strong>l2</strong>: int orbital angular momentum of initial and final states</li>
<li><strong>V</strong>: numpy array of float – length should be min(<strong>l1</strong> ,**l2**)*2+1</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>Vm</strong>: numpy array of float, shape 2 <strong>l1</strong> +1 x 2 <strong>l2</strong> +1</li>
</ul>
</dd>
</dl>
<p><a href="#id133"><span class="problematic" id="id134">**</span></a><a href="#id135"><span class="problematic" id="id136">*</span></a></p>
</dd></dl>

</div>
<div class="section" id="module-chinook.TB_lib">
<span id="tb-lib"></span><h2>TB_lib:<a class="headerlink" href="#module-chinook.TB_lib" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="chinook.TB_lib.H_me">
<em class="property">class </em><code class="descclassname">chinook.TB_lib.</code><code class="descname">H_me</code><span class="sig-paren">(</span><em>i</em>, <em>j</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.TB_lib.H_me" title="Permalink to this definition">¶</a></dt>
<dd><p>This class contains the relevant executables and data structure pertaining 
to generation of the Hamiltonian matrix elements for a single set of 
coupled basis orbitals. Its attributes include integer values 
<strong>i</strong>, <strong>j</strong> indicating the basis indices, and a list of hopping
vectors/matrix element values for the Hamiltonian.</p>
<p>The method <strong>H2Hk</strong> provides an executable function of momentum to allow
broadcasting of the Hamiltonian over a large array of momenta.
Python’s flexible protocol for equivalency and passing variables by
reference/value require definition of a copy operator which allows one to
produce safely, a copy of the object rather than its coordinates 
in memory alone.
<a href="#id137"><span class="problematic" id="id138">**</span></a><a href="#id139"><span class="problematic" id="id140">*</span></a></p>
<dl class="method">
<dt id="chinook.TB_lib.H_me.H2Hk">
<code class="descname">H2Hk</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chinook.TB_lib.H_me.H2Hk" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the list of hopping elements into a Fourier-series expansion 
of the Hamiltonian. This is run during diagonalization for each
matrix element index</p>
<dl class="docutils">
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li>lambda function of a numpy array of float of length 3</li>
</ul>
</dd>
</dl>
<p><a href="#id141"><span class="problematic" id="id142">**</span></a><a href="#id143"><span class="problematic" id="id144">*</span></a></p>
</dd></dl>

<dl class="method">
<dt id="chinook.TB_lib.H_me.append_H">
<code class="descname">append_H</code><span class="sig-paren">(</span><em>R0</em>, <em>R1</em>, <em>R2</em>, <em>H</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.TB_lib.H_me.append_H" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new hopping path to the coupling of the parent orbitals.</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first simple">
<li><strong>R0</strong>, <strong>R1</strong>, <strong>R2</strong>: float connecting vector in cartesian</li>
</ul>
<p>coordinate frame–this is the TOTAL vector, not the relevant 
lattice vectors only</p>
<ul class="last simple">
<li><strong>H</strong>: complex float, matrix element strength</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first simple">
<li>directly modifies the Hamiltonian list for these matrix</li>
</ul>
<p class="last">coordinates</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="chinook.TB_lib.H_me.clean_H">
<code class="descname">clean_H</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chinook.TB_lib.H_me.clean_H" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all duplicate instances of hopping elements in the matrix 
element list. This function is run automatically during slab generation.</p>
<p>The Hamiltonian list is not itself directly modified.</p>
<dl class="docutils">
<dt><em>return</em>:</dt>
<dd><ul class="first simple">
<li>list of hopping vectors and associated Hamiltonian matrix</li>
</ul>
<p class="last">element strengths</p>
</dd>
</dl>
<p><a href="#id145"><span class="problematic" id="id146">**</span></a><a href="#id147"><span class="problematic" id="id148">*</span></a></p>
</dd></dl>

<dl class="method">
<dt id="chinook.TB_lib.H_me.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chinook.TB_lib.H_me.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy by value of the <strong>H_me</strong> object</p>
<dl class="docutils">
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>H_copy</strong>: duplicate <strong>H_me</strong> object</li>
</ul>
</dd>
</dl>
<p><a href="#id149"><span class="problematic" id="id150">**</span></a><a href="#id151"><span class="problematic" id="id152">*</span></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="chinook.TB_lib.TB_model">
<em class="property">class </em><code class="descclassname">chinook.TB_lib.</code><code class="descname">TB_model</code><span class="sig-paren">(</span><em>basis</em>, <em>H_args</em>, <em>Kobj=None</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.TB_lib.TB_model" title="Permalink to this definition">¶</a></dt>
<dd><p>The <strong>TB_model</strong> object carries the model basis as a list of <strong>orbital</strong>
objects, as well as the model Hamiltonian, as a list of <strong>H_me</strong>.</p>
<dl class="method">
<dt id="chinook.TB_lib.TB_model.build_ham">
<code class="descname">build_ham</code><span class="sig-paren">(</span><em>H_args</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.TB_lib.TB_model.build_ham" title="Permalink to this definition">¶</a></dt>
<dd><p>Buld the Hamiltonian using functions from <strong>chinook.H_library.py</strong></p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first simple">
<li><strong>H_args</strong>: dictionary, containing all relevant information for</li>
</ul>
<p class="last">defining the Hamiltonian list. For details, see <strong>TB_model.__init__</strong>.</p>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first simple">
<li>sorted list of matrix element objects. These objects have</li>
</ul>
<p class="last">i,j attributes referencing the orbital basis indices, 
and a list of form [R0,R1,R2,Re(H)+1.0jIm(H)]</p>
</dd>
</dl>
<p><a href="#id153"><span class="problematic" id="id154">**</span></a><a href="#id155"><span class="problematic" id="id156">*</span></a></p>
</dd></dl>

<dl class="method">
<dt id="chinook.TB_lib.TB_model.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chinook.TB_lib.TB_model.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy by value of the <strong>TB_model</strong> object</p>
<dl class="docutils">
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>TB_copy</strong>: duplicate of the <strong>TB_model</strong> object.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="chinook.TB_lib.TB_model.plotting">
<code class="descname">plotting</code><span class="sig-paren">(</span><em>win_min=None</em>, <em>win_max=None</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.TB_lib.TB_model.plotting" title="Permalink to this definition">¶</a></dt>
<dd><p>Plotting routine for a tight-binding model evaluated over some path in k.
If the model has not yet been diagonalized, it is done automatically
before proceeding.</p>
<dl class="docutils">
<dt><em>kwargs</em>:</dt>
<dd><ul class="first simple">
<li><strong>win_min</strong>, <strong>win_max</strong>: float, vertical axis limits for plotting</li>
</ul>
<p class="last">in units of eV. If not passed, a reasonable choice is made which 
covers the entire eigenspectrum.</p>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>ax</strong>: matplotlib axes object</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="chinook.TB_lib.TB_model.print_basis_summary">
<code class="descname">print_basis_summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chinook.TB_lib.TB_model.print_basis_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Very basic print function for printing a summary
of the orbital basis, including their label, atomic species, position
and spin character.</p>
</dd></dl>

<dl class="method">
<dt id="chinook.TB_lib.TB_model.solve_H">
<code class="descname">solve_H</code><span class="sig-paren">(</span><em>Eonly=False</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.TB_lib.TB_model.solve_H" title="Permalink to this definition">¶</a></dt>
<dd><p>This function diagonalizes the Hamiltonian over an array of momentum vectors.
It uses the <strong>mat_el</strong> objects to quickly define lambda functions of 
momentum, which are then filled into the array and diagonalized.
According to <a class="reference external" href="https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/20050192421.pdf">https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/20050192421.pdf</a>
SVD algorithms require memory of 2*order*(4*order + 1) ~ 8*order^2. The matrices are
complex float, so this should be 16 bytes per entry: so len(k)*(2048*order**2). If 
the diagonalization is requesting more than 85% of the available memory, then split
up the k-path into sequential diagonalizations.</p>
<dl class="docutils">
<dt><em>return</em>:</dt>
<dd><ul class="first simple">
<li><strong>self.Eband</strong>: numpy array of float, shape(len(self.Kobj.kpts),len(self.basis)),</li>
</ul>
<p>eigenvalues</p>
<ul class="simple">
<li><strong>self.Evec</strong>: numpy array of complex float, shape(len(self.Kobj.kpts),len(self.basis),len(self.basis))</li>
</ul>
<p class="last">eigenvectors</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="chinook.TB_lib.gen_H_obj">
<code class="descclassname">chinook.TB_lib.</code><code class="descname">gen_H_obj</code><span class="sig-paren">(</span><em>htmp</em><span class="sig-paren">)</span><a class="headerlink" href="#chinook.TB_lib.gen_H_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a list of Hamiltonian matrix elements in list format:
[i,j,Rij[0],Rij[1],Rij[2],Hij(R)] and generate a list of <strong>H_me</strong>
objects instead. This collects all related matrix elements for a given
orbital-pair for convenient generation of the matrix Hamiltonians over
an input array of momentum</p>
<dl class="docutils">
<dt><em>args</em>:</dt>
<dd><ul class="first last simple">
<li><strong>htmp</strong>: list of numeric-type values (mixed integer[:2], float[2:5], complex-float[-1])</li>
</ul>
</dd>
<dt><em>return</em>:</dt>
<dd><ul class="first last simple">
<li><strong>Hlist</strong>: list of Hamiltonian matrix element, <strong>H_me</strong> objects</li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">chinook</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html#contact">Contact</a></li>
<li class="toctree-l1"><a class="reference internal" href="arpes.html">ARPES Simulation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tight Binding</a></li>
<li class="toctree-l1"><a class="reference internal" href="operator.html">Model Diagnostics</a></li>
<li class="toctree-l1"><a class="reference internal" href="slab.html">Slab Calculation</a></li>
<li class="toctree-l1"><a class="reference internal" href="support.html">Support Files</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="arpes.html" title="previous chapter">ARPES Simulation</a></li>
      <li>Next: <a href="operator.html" title="next chapter">Model Diagnostics</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Ryan P. Day.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
      |
      <a href="_sources/tightbinding.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>